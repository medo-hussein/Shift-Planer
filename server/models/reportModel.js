import mongoose from "mongoose";

const reportSchema = new mongoose.Schema({
  // Report type
  type: {
    type: String,
    enum: ["attendance", "overtime", "productivity", "summary", "custom", "shift", "performance"],
    required: true
  },
  
  // Report period
  period: {
    type: String,
    enum: ["daily", "weekly", "monthly", "yearly", "custom"],
    required: true
  },
  
  // Start date of report period
  start_date: { 
    type: Date, 
    required: true 
  },
  
  // End date of report period
  end_date: { 
    type: Date, 
    required: true 
  },
  
  // Report title
  title: {
    type: String,
    required: true,
    trim: true
  },
  
  // Report description (optional)
  description: {
    type: String,
    trim: true,
    default: ""
  },
  
  // The admin who generated this report (branch admin)
  generated_by_admin_id: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: "User", 
    required: true 
  },
  
  super_admin_id: {
    type: mongoose.Schema.Types.ObjectId, 
    ref: "User", 
    required: true,
    index: true
  },

  // Employee ID if this is an employee-specific report
  employee_id: {
    type: mongoose.Schema.Types.ObjectId, 
    ref: "User"
  },
  
  // Flexible data structure for different report types
  data: { 
    type: mongoose.Schema.Types.Mixed, 
    required: true 
  },
  
  // Report format (e.g., summary, detailed, chart)
  format: {
    type: String,
    enum: ["summary", "detailed", "chart", "table"],
    default: "summary"
  },
  
  // Whether report was generated by AI
  is_ai_generated: { 
    type: Boolean, 
    default: false 
  },

  // New field to store the AI-generated text summary
  ai_summary: {
    type: String,
    default: ""
  },
  
  // Report visibility and sharing
  is_public: {
    type: Boolean,
    default: false
  },
  
  // Who can access this report
  access_level: {
    type: String,
    enum: ["private", "branch", "company_wide"],
    default: "private"
  },
  
  // Specific users this report is shared with
  shared_with_users: [{
    type: mongoose.Schema.Types.ObjectId, 
    ref: "User"
  }],
  
  // Report status
  status: {
    type: String,
    enum: ["generating", "completed", "failed", "archived"],
    default: "completed"
  },
  
  // File information if exported
  export_info: {
    file_path: String,
    file_format: {
      type: String,
      enum: ["pdf", "excel", "csv", "json"]
    },
    file_size: Number,
    exported_at: Date
  }
}, { 
  timestamps: true 
});

// Indexes for quick retrieval and filtering
reportSchema.index({ generated_by_admin_id: 1, type: 1, start_date: 1 });
reportSchema.index({ employee_id: 1, type: 1 });
reportSchema.index({ generated_by_admin_id: 1, created_at: -1 });
reportSchema.index({ access_level: 1, is_public: 1 });

reportSchema.index({ super_admin_id: 1, created_at: -1 });

// Virtual for report period display
reportSchema.virtual("period_display").get(function() {
  const periodMap = {
    daily: "Daily",
    weekly: "Weekly", 
    monthly: "Monthly",
    yearly: "Yearly",
    custom: "Custom Range"
  };
  return periodMap[this.period] || this.period;
});

// Virtual to check if report is for specific employee
reportSchema.virtual("is_employee_report").get(function() {
  return !!this.employee_id;
});

// Method to check if user can access this report
reportSchema.methods.canUserAccess = function(userId, userRole) {
  // Super admin can access all reports
  if (userRole === "super_admin") return true;
  
  // Report generator can always access their own reports
  if (this.generated_by_admin_id.toString() === userId.toString()) return true;
  
  // Check if user is specifically shared with
  if (this.shared_with_users.some(user => user.toString() === userId.toString())) return true;
  
  // Check access level
  if (this.access_level === "branch") {
    // For branch level, check if user belongs to the same branch
    return false; 
  }
  
  if (this.access_level === "company_wide" && this.is_public) {
    return true;
  }
  
  return false;
};

// Method to share report with specific users
reportSchema.methods.shareWithUsers = function(userIds) {
  this.shared_with_users = [...new Set([...this.shared_with_users, ...userIds])];
  return this.save();
};

// Method to revoke access from users
reportSchema.methods.revokeAccessFromUsers = function(userIds) {
  this.shared_with_users = this.shared_with_users.filter(
    userId => !userIds.includes(userId.toString())
  );
  return this.save();
};

// Static method to find reports by admin and date range
reportSchema.statics.findByAdminAndDateRange = function(adminId, startDate, endDate) {
  return this.find({
    generated_by_admin_id: adminId,
    start_date: { $gte: startDate },
    end_date: { $lte: endDate }
  }).sort({ created_at: -1 });
};

// Static method to find employee-specific reports
reportSchema.statics.findEmployeeReports = function(employeeId, adminId = null) {
  const query = { employee_id: employeeId };
  
  if (adminId) {
    query.generated_by_admin_id = adminId;
  }
  
  return this.find(query).sort({ created_at: -1 });
};

// Static method to find public/branch reports for employees
reportSchema.statics.findAccessibleReports = function(adminId) {
  return this.find({
    $or: [
      { generated_by_admin_id: adminId },
      { access_level: "branch" },
      { access_level: "company_wide", is_public: true }
    ]
  }).sort({ created_at: -1 });
};

// Pre-save middleware to validate dates
reportSchema.pre("save", function(next) {
  if (this.start_date > this.end_date) {
    return next(new Error("Start date cannot be after end date"));
  }
  next();
});

export default mongoose.model("Report", reportSchema);